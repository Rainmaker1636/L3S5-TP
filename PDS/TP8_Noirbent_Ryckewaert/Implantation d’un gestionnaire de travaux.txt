<!DOCTYPE html>
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.23">
<link rel="stylesheet" type="text/css" href="Implantation%20d%E2%80%99un%20gestionnaire%20de%20travaux_fichiers/feuille.css"><link rel="stylesheet" type="text/css" href="Implantation%20d%E2%80%99un%20gestionnaire%20de%20travaux_fichiers/tdjobs-.css">
<title>Implantation d’un gestionnaire de travaux</title>
</head>
<body>
<a href="http://www.fil.univ-lille1.fr/%7Ehym/e/pds/tp/tdjobs-gs.html"><img src="Implantation%20d%E2%80%99un%20gestionnaire%20de%20travaux_fichiers/previous.png" alt="Précédent"></a>
<a href="http://www.fil.univ-lille1.fr/%7Ehym/e/pds/tp/tdjobs.html"><img src="Implantation%20d%E2%80%99un%20gestionnaire%20de%20travaux_fichiers/contents.png" alt="Table des matières"></a>
<a href="http://www.fil.univ-lille1.fr/%7Ehym/e/pds/tp/tdjobs-pipe.html"><img src="Implantation%20d%E2%80%99un%20gestionnaire%20de%20travaux_fichiers/next.png" alt="Suivant"></a>
<hr>
<h2 id="sec5" class="section">2&nbsp;&nbsp;Implantation d’un gestionnaire de travaux</h2>
<div class="theorem"><span style="font-weight:bold"><br>
Exercice&nbsp;2</span>&nbsp;<span style="font-weight:bold">(Structures de données pour les jobs et fonctions
associées)</span>&nbsp;&nbsp;<em>
La gestion des différents jobs nécessite de maintenir des
informations sur chaque job. Un job est identifié par son pid ou
bien son job id, ces numéros lui sont attribués à son lancement.
Ainsi, par exemple, le job </em><em><span style="font-family:monospace">xeyes</span></em><em> de la session shell montrée
précédemment a pour pid 503 et pour job id 2. De plus, à tout
moment, on a besoin de savoir si le job est exécuté en
arrière-plan (BG), en avant-plan (FG) ou s’il est stoppé (ST).</em><p><em>Proposez des structures de données pour représenter toutes ces
informations. De plus, proposez un ensemble de fonctions
permettant de manipuler ces structures.

</em></p></div>
<h3 id="sec6" class="subsection">Traitants de signal</h3>
<p>Il est nécessaire de rediriger les signaux <span style="font-family:monospace">SIGINT</span>,
<span style="font-family:monospace">SIGTSTP</span> et <span style="font-family:monospace">SIGCHLD</span> envoyés au mini-shell par le
système. Un signal <span style="font-family:monospace">SIGINT</span> est envoyé à chaque fois que
l’utilisateur fait un <span style="font-family:monospace">Ctrl+C</span> au clavier. Un signal
<span style="font-family:monospace">SIGTSTP</span> est envoyé lors d’un <span style="font-family:monospace">Ctrl+Z</span>. Enfin le
signal <span style="font-family:monospace">SIGCHLD</span> est envoyé à chaque fois que l’exécution
d’un programme lancé dans le mini-shell a terminé ou a été bloquée.</p><div class="theorem"><span style="font-weight:bold"><br>
Exercice&nbsp;3</span>&nbsp;&nbsp;<em>
Il est nécessaire d’installer des traitants de signal pour
personnaliser le traitement des signaux </em><em><span style="font-family:monospace">SIGINT</span></em><em>,
</em><em><span style="font-family:monospace">SIGTSTP</span></em><em> et </em><em><span style="font-family:monospace">SIGCHLD</span></em><em>. Donnez l’implémentation
de la fonction </em><em><span style="font-family:monospace">sigaction_wrapper()</span></em><em>
</em><blockquote class="quote"><em>
</em><pre class="verbatim"><em>typedef void handler_t(int);
int sigaction_wrapper(int signum, handler_t *handler);
</em></pre></blockquote><em>
qui permet d’associer un traitant à un signal donné.

</em></div><div class="theorem"><span style="font-weight:bold"><br>
Exercice&nbsp;4</span>&nbsp;&nbsp;<em>
Donnez l’implémentation du traitant de signal pour
</em><em><span style="font-family:monospace">SIGINT</span></em><em> :
</em><blockquote class="quote"><em>
</em><pre class="verbatim"><em>void sigint_handler(int sig);
</em></pre></blockquote><em>
Ce traitant redirige le signal vers le processus qui est en
avant-plan afin de provoquer sa terminaison.

</em></div><div class="theorem"><span style="font-weight:bold"><br>
Exercice&nbsp;5</span>&nbsp;&nbsp;<em>
Donnez l’implémentation du traitant de signal pour
</em><em><span style="font-family:monospace">SIGTSTP</span></em><em> :
</em><blockquote class="quote"><em>
</em><pre class="verbatim"><em>void sigstp_handler(int sig);
</em></pre></blockquote><em>
Ce traitant redirige le signal vers le processus qui est en
avant-plan afin de le suspendre.

</em></div><div class="theorem"><span style="font-weight:bold"><br>
Exercice&nbsp;6</span>&nbsp;&nbsp;<em>
Donnez l’implémentation du traitant de signal pour
</em><em><span style="font-family:monospace">SIGCHLD</span></em><em> :
</em><blockquote class="quote"><em>
</em><pre class="verbatim"><em>void sigchld_handler(int sig);
</em></pre></blockquote><em>
Ce traitant recherche tous les jobs terminés ou stoppés. Il
détermine si le job a été stoppé, terminé par un signal ou a
terminé normalement son exécution. Selon les cas, les structures
de données sont mises à jour de façon appropriée et un message est
affiché sur la sortie standard pour renseigner sur l’état du
job.

</em></div><div class="encart"><h3 id="sec7" class="subsection">Organisation du code du gestionnaire de travaux</h3>
<p> <a id="enc:code"></a>
Les fichiers sources d’un squelette de l’implantation d’un
gestionnaire de travaux sont disponibles sur le portail.</p><p>Vous y trouverez :
</p><ul class="itemize"><li class="li-itemize">
un <span style="font-family:monospace">Makefile</span> ;
</li><li class="li-itemize"><span style="font-family:monospace">mshell.c</span> : contient entre autres le <span style="font-family:monospace">main()</span> ;
</li><li class="li-itemize"><span style="font-family:monospace">cmd.c</span>, <span style="font-family:monospace">cmd.h</span> : contient les commandes
<span style="font-family:monospace">fg</span>, <span style="font-family:monospace">bg</span>, <span style="font-family:monospace">stop</span>...
</li><li class="li-itemize"><span style="font-family:monospace">jobs.c</span>, <span style="font-family:monospace">jobs.h</span> : contient la bibliothèque gérant
les structures de données associées aux jobs ;
</li><li class="li-itemize"><span style="font-family:monospace">sighandlers.c</span>, <span style="font-family:monospace">sighandlers.h</span> : contient les
traitants de signaux ;
</li><li class="li-itemize"><span style="font-family:monospace">common.c</span>, <span style="font-family:monospace">common.h</span> : contient des données et
fonctions communes aux différents fichiers.
</li></ul><p>
A priori, vous n’avez à modifier que les fichiers <span style="font-family:monospace">cmd.c</span> et
<span style="font-family:monospace">sighandlers.c</span>. Les squelettes des fonctions à implémenter sont
déjà donnés ; aucune autre fonction n’est nécessaire.
</p><p>
<br>

Le mini-shell peut fonctionner en mode <span style="font-style:italic">verbose</span> (<span style="font-family:monospace">mshell
-v</span>) ce qui permet d’avoir des informations sur les traitants et
fonctions sollicités, etc. Une variable globale <span style="font-family:monospace">verbose</span> est
prévue à cet effet. Pensez à l’utiliser ! Le fichier <span style="font-family:monospace">jobs.c</span>
contient un exemple de son utilisation, à vous de voir selon les
situations quelles informations afficher.
</p></div><div class="encart"><h3 id="sec8" class="subsection">Comment tester les traitants de signal ?</h3>
<p> 
Pour tester les premières fonctionnalités du mini-shell, il est
proposé ci-dessous quelques idées.
</p><p>
Pour réaliser ces tests il est nécessaire que la fonction
<span style="font-family:monospace">waitfg</span> soit implémentée. Il est mieux aussi que dans la
fonction <span style="font-family:monospace">sigchld_handler</span> il y ait impression à l’écran de
messages explicites en mode verbeux afin de bien comprendre ce qui
se passe.
</p><p>
Lancer le mini-shell en mode verbeux puis:
</p><ul class="itemize"><li class="li-itemize">
lancer <span style="font-family:monospace">xclock</span> (en avant-plan), le tuer avec
<span style="font-family:monospace">Ctrl-C</span>, observer la trace qui doit passer par les
fonctions <span style="font-family:monospace">sigint_handler</span> puis
<span style="font-family:monospace">sigchld_handler</span>;
</li><li class="li-itemize">lancer <span style="font-family:monospace">xclock -update 1</span> (en avant-plan),
l’interrompre avec <span style="font-family:monospace">Ctrl-Z</span>, observer la trace qui doit
passer par les fonctions <span style="font-family:monospace">sigstp_handler</span> et
<span style="font-family:monospace">sigchld_handler</span>. Dans un autre terminal, envoyer le
signal SIGKILL avec la commande kill sur le processus
correspondant à <span style="font-family:monospace">xclock</span>, observer la trace qui doit
passer par la fonction <span style="font-family:monospace">sigchld_handler</span>;
</li><li class="li-itemize">lancer <span style="font-family:monospace">xclock -update 1</span> puis avec la commande
<span style="font-family:monospace">kill</span> dans un autre terminal envoyer le signal
<span style="font-family:monospace">SIGTSTP</span> puis <span style="font-family:monospace">SIGCONT</span> sur le processus
correspondant à <span style="font-family:monospace">xclock</span>, observer le comportement de
<span style="font-family:monospace">xclock</span> et la trace qui doit passer par
<span style="font-family:monospace">sigchld_handler</span>. Combien de fois passe-t-on par ce
gestionnaire de signal ? Pourquoi ?
Pourquoi ne passe-t-on pas par <span style="font-family:monospace">sigstp_handler</span> ?
</li><li class="li-itemize">créer un petit programme qui dure 10 secondes et s’arrête
grâce à <span style="font-family:monospace">exit</span>, observer le comportement.
</li></ul></div>
<h3 id="sec9" class="subsection">Commandes du mini-shell</h3>
<p>Le mini-shell offre un certain nombre de commandes :
</p><ul class="itemize"><li class="li-itemize">
<span style="font-family:monospace">exit</span> permet de quitter le mini-shell
</li><li class="li-itemize"><span style="font-family:monospace">stop</span> permet d’arrêter un job
</li><li class="li-itemize"><span style="font-family:monospace">kill</span> permet de provoquer la terminaison d’un job
</li><li class="li-itemize"><span style="font-family:monospace">bg</span> envoie un job en arrière-plan
</li><li class="li-itemize"><span style="font-family:monospace">fg</span> met un job en avant-plan
</li><li class="li-itemize"><span style="font-family:monospace">jobs</span> donne des informations sur les jobs courants
</li></ul><div class="theorem"><span style="font-weight:bold"><br>
Exercice&nbsp;7</span>&nbsp;&nbsp;<em>
La commande </em><em><span style="font-family:monospace">fg</span></em><em> est invoquée soit par </em><em><span style="font-family:monospace">fg
</span></em><em><span style="font-family:monospace"><em>pid</em></span></em><em> soit par </em><em><span style="font-family:monospace">fg </span></em><em><span style="font-family:monospace"><em>jid</em></span></em><em>.</em><p><em>Le prototype de la fonction implémentant la commande </em><em><span style="font-style:italic">fg</span></em><em> est
le suivant :
</em></p><blockquote class="quote"><em>
</em><pre class="verbatim"><em>void do_fg(char **argv);
</em></pre></blockquote><p><em>
</em><em><span style="font-family:monospace">argv</span></em><em> contient la chaîne de caractères correspondant à la
commande tapée dans le mini-shell, comme par exemple </em><em><span style="font-family:monospace">"fg
%1"</span></em><em>. Une fonction </em><em><span style="font-family:monospace">treat_argv()</span></em><em> est mise à votre
disposition pour chercher un job dans la liste des travaux en
fonction d’un pid ou d’un jid. Son prototype est :
</em></p><blockquote class="quote"><em>
</em><pre class="verbatim"><em>struct job_t * treat_argv(char **argv);
</em></pre></blockquote><p><em>
La valeur </em><em><span style="font-family:monospace">NULL</span></em><em> est retournée si aucun job n’a été
trouvé.</em></p><p><em><br>
</em></p><p><em>Lorsqu’un job est exécuté en avant-plan, l’utilisateur n’a pas la
main. Pour pouvoir implémenter ce comportement, écrivez une
fonction
</em></p><blockquote class="quote"><em>
</em><pre class="verbatim"><em>void waitfg(pid_t pid)
</em></pre></blockquote><p><em>
qui bloque tant que le job </em><em><span style="font-family:monospace">pid</span></em><em> n’est pas mis en
arrière-plan ou terminé.
</em></p><p><em>La fonction </em><em><span style="font-family:monospace">do_fg()</span></em><em> envoie le signal approprié au job qui
doit être passé en avant-plan, met à jour les informations
associées au job et bloque tant que le job n’est pas passé en
arrière-plan. Donnez son implémentation.
</em></p><p><em>Les commandes </em><em><span style="font-family:monospace">bg</span></em><em>, </em><em><span style="font-family:monospace">stop</span></em><em> et </em><em><span style="font-family:monospace">kill</span></em><em> sont
invoquées sur le même modèle que </em><em><span style="font-family:monospace">fg</span></em><em> et sont
respectivement implémentées par :
</em></p><blockquote class="quote"><em>
</em><pre class="verbatim"><em>void do_bg(char **argv);
void do_stop(char **argv);
void do_kill(char **argv);
</em></pre></blockquote><p><em>
Donnez leurs implémentations.

</em></p></div><div class="theorem"><span style="font-weight:bold"><br>
Exercice&nbsp;8</span>&nbsp;&nbsp;<em>
La commande </em><em><span style="font-family:monospace">exit</span></em><em> permet de sortir du mini-shell. Le
prototype de la fonction qui implémente </em><em><span style="font-family:monospace">exit</span></em><em> est le
suivant :
</em><blockquote class="quote"><em>
</em><pre class="verbatim"><em>void do_exit();
</em></pre></blockquote><em>
Inspirez-vous du comportement du shell que vous utilisez
habituellement (cette remarque est d’ailleurs aussi valable pour
toutes les autres commandes). Par exemple, que se passe-t-il
lorsque vous faites un exit dans un shell alors qu’un job de ce
shell est arrêté ?

</em></div><div class="theorem"><span style="font-weight:bold"><br>
Exercice&nbsp;9</span>&nbsp;&nbsp;<em>
La commande </em><em><span style="font-family:monospace">jobs</span></em><em> affiche l’état de tous les jobs lancés
dans le mini-shell, voyez l’exemple donné en début de document.</em><p><em>La fonction qui implémente cette commande a pour prototype :
</em></p><blockquote class="quote"><em>
</em><pre class="verbatim"><em>void do_jobs();
</em></pre></blockquote><p><em>
Implémentez cette fonction.

</em></p></div>
<hr>
<a href="http://www.fil.univ-lille1.fr/%7Ehym/e/pds/tp/tdjobs-gs.html"><img src="Implantation%20d%E2%80%99un%20gestionnaire%20de%20travaux_fichiers/previous.png" alt="Précédent"></a>
<a href="http://www.fil.univ-lille1.fr/%7Ehym/e/pds/tp/tdjobs.html"><img src="Implantation%20d%E2%80%99un%20gestionnaire%20de%20travaux_fichiers/contents.png" alt="Table des matières"></a>
<a href="http://www.fil.univ-lille1.fr/%7Ehym/e/pds/tp/tdjobs-pipe.html"><img src="Implantation%20d%E2%80%99un%20gestionnaire%20de%20travaux_fichiers/next.png" alt="Suivant"></a>


</body></html>